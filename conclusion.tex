\clearpage
\section{Conclusion}
In conclusion, this document presents our study on the software system called OptaPlanner, a constraint problem-solver, which can also be used to solve user-defined problems. Our study consisted of four steps; in step 1 we conducted a top-down introductory analysis on the software by retracting as much information as possible from the documentation guides and online information. Based on that information we compiled a list of quality attributes which we used to define some architecturally significant requirements and initial hypotheses on the architecture components of the system. \\\\
In step 2 we focused on a more thorough analysis using the bottom-up model; we start from the code-base and work our way through the whole system. In order to gain as much insight as possible, we used software tools like the IntelliJ IDE and Structure 101. At the end of this step, we had discerned the main architectural components of the system and the entities that comprised them. We had also established several relationships between the components which we have tackled carefully in the previous sections.\\\\
Once we established a good outlook on the software at hand, in step 3 we focused on the quality of its source code, and more specifically, the architectural components with a focus on code smells, code duplication, complexity and more. 
The Sonarqube tool was used for this purpose.\\\\
Finally, in step 4, we focused on the design quality of the software system and its architecture, with a special focus on the design differences among the main architectural components. More specifically, we analysed the possible design decisions that the OptaPlanner team has taken throughout its development. The tools that were used throughout this step were Structure 101 and Designite.\\\\
At the end of this project, we have learned how to approach working with a new software system and eventually, be able to maintain it consistently. We learned that the best approach is to work incrementally, starting with a top-down model where we try to gather as much high-level information as possible, and then proceeding with the source-code. We noted that a combination of both models, top-down and bottom-up proved most helpful in analyzing the source-code. Nonetheless, we also learned that smart design decisions can prove very helpful not only in the development process of a software system but also after it has been delivered and it is ready for use. As important as it is for the end-users of the software system to work with a good product, it is as important that the system is maintained continuously. This will render the system future-proof and it will pave the way for future software engineers that will have to work on the system.
